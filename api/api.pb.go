// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	EmptyResponse
	EmptyReq
	UserResponse
	User
	TxInfoResponse
	TxInfo
	CreateTokenReq
	TokenResponse
	Token
	VerifyTokenReq
	MetadataResponse
	Metadata
	PathReq
	MoveReq
	TxChunk
	WriteSummaryResponse
	WriteSummary
	TxEnd
	DataChunkResponse
	DataChunk
	RevisionResponse
	Revision
	RevisionReq
	RecycleEntryResponse
	RecycleEntry
	RecycleEntryReq
	LinkPermissions
	NewLinkReq
	UpdateLinkReq
	PublicLinkResponse
	PublicLink
	TokenReq
	FolderShareResponse
	FolderShare
	ReceivedShareResponse
	ReceivedShare
	NewFolderShareReq
	UpdateFolderShareReq
	UnshareFolderReq
	ListFolderSharesReq
	ReceivedShareReq
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_OK                       StatusCode = 0
	StatusCode_UNKNOWN                  StatusCode = 1
	StatusCode_STORAGE_NOT_FOUND        StatusCode = 2
	StatusCode_STORAGE_ALREADY_EXISTS   StatusCode = 3
	StatusCode_STORAGE_PERMISSIONDENIED StatusCode = 4
	StatusCode_CONTEXT_USER_REQUIRED    StatusCode = 5
	StatusCode_PATH_INVALID             StatusCode = 6
	StatusCode_PUBLIC_LINK_NOT_FOUND    StatusCode = 7
	StatusCode_PUBLIC_LINK_INVALID_DATE StatusCode = 8
	StatusCode_STORAGE_NOT_SUPPORTED    StatusCode = 9
	StatusCode_USER_NOT_FOUND           StatusCode = 10
	StatusCode_TOKEN_INVALID            StatusCode = 11
)

var StatusCode_name = map[int32]string{
	0:  "OK",
	1:  "UNKNOWN",
	2:  "STORAGE_NOT_FOUND",
	3:  "STORAGE_ALREADY_EXISTS",
	4:  "STORAGE_PERMISSIONDENIED",
	5:  "CONTEXT_USER_REQUIRED",
	6:  "PATH_INVALID",
	7:  "PUBLIC_LINK_NOT_FOUND",
	8:  "PUBLIC_LINK_INVALID_DATE",
	9:  "STORAGE_NOT_SUPPORTED",
	10: "USER_NOT_FOUND",
	11: "TOKEN_INVALID",
}
var StatusCode_value = map[string]int32{
	"OK":                       0,
	"UNKNOWN":                  1,
	"STORAGE_NOT_FOUND":        2,
	"STORAGE_ALREADY_EXISTS":   3,
	"STORAGE_PERMISSIONDENIED": 4,
	"CONTEXT_USER_REQUIRED":    5,
	"PATH_INVALID":             6,
	"PUBLIC_LINK_NOT_FOUND":    7,
	"PUBLIC_LINK_INVALID_DATE": 8,
	"STORAGE_NOT_SUPPORTED":    9,
	"USER_NOT_FOUND":           10,
	"TOKEN_INVALID":            11,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}
func (StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type EmptyResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EmptyResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

type EmptyReq struct {
}

func (m *EmptyReq) Reset()                    { *m = EmptyReq{} }
func (m *EmptyReq) String() string            { return proto.CompactTextString(m) }
func (*EmptyReq) ProtoMessage()               {}
func (*EmptyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type UserResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	User   *User      `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *UserResponse) Reset()                    { *m = UserResponse{} }
func (m *UserResponse) String() string            { return proto.CompactTextString(m) }
func (*UserResponse) ProtoMessage()               {}
func (*UserResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UserResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *UserResponse) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type User struct {
	AccountId string   `protobuf:"bytes,1,opt,name=account_id,json=accountId" json:"account_id,omitempty"`
	Groups    []string `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *User) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *User) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

type TxInfoResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	TxInfo *TxInfo    `protobuf:"bytes,2,opt,name=txInfo" json:"txInfo,omitempty"`
}

func (m *TxInfoResponse) Reset()                    { *m = TxInfoResponse{} }
func (m *TxInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*TxInfoResponse) ProtoMessage()               {}
func (*TxInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TxInfoResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *TxInfoResponse) GetTxInfo() *TxInfo {
	if m != nil {
		return m.TxInfo
	}
	return nil
}

type TxInfo struct {
	TxId string `protobuf:"bytes,1,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
}

func (m *TxInfo) Reset()                    { *m = TxInfo{} }
func (m *TxInfo) String() string            { return proto.CompactTextString(m) }
func (*TxInfo) ProtoMessage()               {}
func (*TxInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TxInfo) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type CreateTokenReq struct {
	ClientId     string `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	ClientSecret string `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret" json:"client_secret,omitempty"`
}

func (m *CreateTokenReq) Reset()                    { *m = CreateTokenReq{} }
func (m *CreateTokenReq) String() string            { return proto.CompactTextString(m) }
func (*CreateTokenReq) ProtoMessage()               {}
func (*CreateTokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CreateTokenReq) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *CreateTokenReq) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

type TokenResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Token  *Token     `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *TokenResponse) Reset()                    { *m = TokenResponse{} }
func (m *TokenResponse) String() string            { return proto.CompactTextString(m) }
func (*TokenResponse) ProtoMessage()               {}
func (*TokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TokenResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *TokenResponse) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type Token struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Token) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyTokenReq struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *VerifyTokenReq) Reset()                    { *m = VerifyTokenReq{} }
func (m *VerifyTokenReq) String() string            { return proto.CompactTextString(m) }
func (*VerifyTokenReq) ProtoMessage()               {}
func (*VerifyTokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *VerifyTokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type MetadataResponse struct {
	Status   StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Metadata *Metadata  `protobuf:"bytes,2,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *MetadataResponse) Reset()                    { *m = MetadataResponse{} }
func (m *MetadataResponse) String() string            { return proto.CompactTextString(m) }
func (*MetadataResponse) ProtoMessage()               {}
func (*MetadataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MetadataResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *MetadataResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Metadata struct {
	Id        string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Path      string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Size      uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Mtime     uint64 `protobuf:"varint,4,opt,name=mtime" json:"mtime,omitempty"`
	IsDir     bool   `protobuf:"varint,5,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
	Etag      string `protobuf:"bytes,6,opt,name=etag" json:"etag,omitempty"`
	Checksum  string `protobuf:"bytes,7,opt,name=checksum" json:"checksum,omitempty"`
	DerefPath string `protobuf:"bytes,8,opt,name=deref_path,json=derefPath" json:"deref_path,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Metadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Metadata) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Metadata) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Metadata) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *Metadata) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

func (m *Metadata) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *Metadata) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *Metadata) GetDerefPath() string {
	if m != nil {
		return m.DerefPath
	}
	return ""
}

type PathReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *PathReq) Reset()                    { *m = PathReq{} }
func (m *PathReq) String() string            { return proto.CompactTextString(m) }
func (*PathReq) ProtoMessage()               {}
func (*PathReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PathReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type MoveReq struct {
	OldPath string `protobuf:"bytes,1,opt,name=old_path,json=oldPath" json:"old_path,omitempty"`
	NewPath string `protobuf:"bytes,2,opt,name=new_path,json=newPath" json:"new_path,omitempty"`
}

func (m *MoveReq) Reset()                    { *m = MoveReq{} }
func (m *MoveReq) String() string            { return proto.CompactTextString(m) }
func (*MoveReq) ProtoMessage()               {}
func (*MoveReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *MoveReq) GetOldPath() string {
	if m != nil {
		return m.OldPath
	}
	return ""
}

func (m *MoveReq) GetNewPath() string {
	if m != nil {
		return m.NewPath
	}
	return ""
}

// maybe add checksum data ?
type TxChunk struct {
	TxId   string `protobuf:"bytes,1,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
	Length uint64 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Offset uint64 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	Data   []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TxChunk) Reset()                    { *m = TxChunk{} }
func (m *TxChunk) String() string            { return proto.CompactTextString(m) }
func (*TxChunk) ProtoMessage()               {}
func (*TxChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *TxChunk) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxChunk) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *TxChunk) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *TxChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WriteSummaryResponse struct {
	Status       StatusCode    `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	WriteSummary *WriteSummary `protobuf:"bytes,2,opt,name=writeSummary" json:"writeSummary,omitempty"`
}

func (m *WriteSummaryResponse) Reset()                    { *m = WriteSummaryResponse{} }
func (m *WriteSummaryResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteSummaryResponse) ProtoMessage()               {}
func (*WriteSummaryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *WriteSummaryResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *WriteSummaryResponse) GetWriteSummary() *WriteSummary {
	if m != nil {
		return m.WriteSummary
	}
	return nil
}

type WriteSummary struct {
	Nchunks   uint64 `protobuf:"varint,1,opt,name=nchunks" json:"nchunks,omitempty"`
	TotalSize uint64 `protobuf:"varint,2,opt,name=total_size,json=totalSize" json:"total_size,omitempty"`
}

func (m *WriteSummary) Reset()                    { *m = WriteSummary{} }
func (m *WriteSummary) String() string            { return proto.CompactTextString(m) }
func (*WriteSummary) ProtoMessage()               {}
func (*WriteSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *WriteSummary) GetNchunks() uint64 {
	if m != nil {
		return m.Nchunks
	}
	return 0
}

func (m *WriteSummary) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type TxEnd struct {
	TxId     string `protobuf:"bytes,1,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
	Path     string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Checksum string `protobuf:"bytes,3,opt,name=checksum" json:"checksum,omitempty"`
}

func (m *TxEnd) Reset()                    { *m = TxEnd{} }
func (m *TxEnd) String() string            { return proto.CompactTextString(m) }
func (*TxEnd) ProtoMessage()               {}
func (*TxEnd) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *TxEnd) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxEnd) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TxEnd) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

type DataChunkResponse struct {
	Status    StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	DataChunk *DataChunk `protobuf:"bytes,2,opt,name=dataChunk" json:"dataChunk,omitempty"`
}

func (m *DataChunkResponse) Reset()                    { *m = DataChunkResponse{} }
func (m *DataChunkResponse) String() string            { return proto.CompactTextString(m) }
func (*DataChunkResponse) ProtoMessage()               {}
func (*DataChunkResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DataChunkResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *DataChunkResponse) GetDataChunk() *DataChunk {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DataChunk struct {
	Length uint64 `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
	Offset uint64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataChunk) Reset()                    { *m = DataChunk{} }
func (m *DataChunk) String() string            { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()               {}
func (*DataChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DataChunk) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DataChunk) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DataChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RevisionResponse struct {
	Status   StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Revision *Revision  `protobuf:"bytes,2,opt,name=revision" json:"revision,omitempty"`
}

func (m *RevisionResponse) Reset()                    { *m = RevisionResponse{} }
func (m *RevisionResponse) String() string            { return proto.CompactTextString(m) }
func (*RevisionResponse) ProtoMessage()               {}
func (*RevisionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *RevisionResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *RevisionResponse) GetRevision() *Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

type Revision struct {
	RevKey string `protobuf:"bytes,1,opt,name=rev_key,json=revKey" json:"rev_key,omitempty"`
	Size   uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	Mtime  uint64 `protobuf:"varint,3,opt,name=mtime" json:"mtime,omitempty"`
	IsDir  bool   `protobuf:"varint,4,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
}

func (m *Revision) Reset()                    { *m = Revision{} }
func (m *Revision) String() string            { return proto.CompactTextString(m) }
func (*Revision) ProtoMessage()               {}
func (*Revision) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Revision) GetRevKey() string {
	if m != nil {
		return m.RevKey
	}
	return ""
}

func (m *Revision) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Revision) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *Revision) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

type RevisionReq struct {
	Path   string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	RevKey string `protobuf:"bytes,2,opt,name=rev_key,json=revKey" json:"rev_key,omitempty"`
}

func (m *RevisionReq) Reset()                    { *m = RevisionReq{} }
func (m *RevisionReq) String() string            { return proto.CompactTextString(m) }
func (*RevisionReq) ProtoMessage()               {}
func (*RevisionReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *RevisionReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RevisionReq) GetRevKey() string {
	if m != nil {
		return m.RevKey
	}
	return ""
}

type RecycleEntryResponse struct {
	Status       StatusCode    `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	RecycleEntry *RecycleEntry `protobuf:"bytes,2,opt,name=recycleEntry" json:"recycleEntry,omitempty"`
}

func (m *RecycleEntryResponse) Reset()                    { *m = RecycleEntryResponse{} }
func (m *RecycleEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*RecycleEntryResponse) ProtoMessage()               {}
func (*RecycleEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *RecycleEntryResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *RecycleEntryResponse) GetRecycleEntry() *RecycleEntry {
	if m != nil {
		return m.RecycleEntry
	}
	return nil
}

type RecycleEntry struct {
	RestorePath string `protobuf:"bytes,1,opt,name=restore_path,json=restorePath" json:"restore_path,omitempty"`
	RestoreKey  string `protobuf:"bytes,2,opt,name=restore_key,json=restoreKey" json:"restore_key,omitempty"`
	Size        uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	DelMtime    uint64 `protobuf:"varint,4,opt,name=del_mtime,json=delMtime" json:"del_mtime,omitempty"`
	IsDir       bool   `protobuf:"varint,5,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
}

func (m *RecycleEntry) Reset()                    { *m = RecycleEntry{} }
func (m *RecycleEntry) String() string            { return proto.CompactTextString(m) }
func (*RecycleEntry) ProtoMessage()               {}
func (*RecycleEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *RecycleEntry) GetRestorePath() string {
	if m != nil {
		return m.RestorePath
	}
	return ""
}

func (m *RecycleEntry) GetRestoreKey() string {
	if m != nil {
		return m.RestoreKey
	}
	return ""
}

func (m *RecycleEntry) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *RecycleEntry) GetDelMtime() uint64 {
	if m != nil {
		return m.DelMtime
	}
	return 0
}

func (m *RecycleEntry) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

type RecycleEntryReq struct {
	RestoreKey string `protobuf:"bytes,1,opt,name=restore_key,json=restoreKey" json:"restore_key,omitempty"`
}

func (m *RecycleEntryReq) Reset()                    { *m = RecycleEntryReq{} }
func (m *RecycleEntryReq) String() string            { return proto.CompactTextString(m) }
func (*RecycleEntryReq) ProtoMessage()               {}
func (*RecycleEntryReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *RecycleEntryReq) GetRestoreKey() string {
	if m != nil {
		return m.RestoreKey
	}
	return ""
}

type LinkPermissions struct {
	Read  bool `protobuf:"varint,1,opt,name=read" json:"read,omitempty"`
	Write bool `protobuf:"varint,2,opt,name=write" json:"write,omitempty"`
}

func (m *LinkPermissions) Reset()                    { *m = LinkPermissions{} }
func (m *LinkPermissions) String() string            { return proto.CompactTextString(m) }
func (*LinkPermissions) ProtoMessage()               {}
func (*LinkPermissions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *LinkPermissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *LinkPermissions) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type NewLinkReq struct {
	Path     string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	ReadOnly bool   `protobuf:"varint,2,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	Expires  uint64 `protobuf:"varint,4,opt,name=expires" json:"expires,omitempty"`
}

func (m *NewLinkReq) Reset()                    { *m = NewLinkReq{} }
func (m *NewLinkReq) String() string            { return proto.CompactTextString(m) }
func (*NewLinkReq) ProtoMessage()               {}
func (*NewLinkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *NewLinkReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *NewLinkReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *NewLinkReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *NewLinkReq) GetExpires() uint64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

type UpdateLinkReq struct {
	Token            string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	UpdatePassword   bool   `protobuf:"varint,2,opt,name=update_password,json=updatePassword" json:"update_password,omitempty"`
	Password         string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	UpdateExpiration bool   `protobuf:"varint,4,opt,name=update_expiration,json=updateExpiration" json:"update_expiration,omitempty"`
	Expiration       uint64 `protobuf:"varint,5,opt,name=expiration" json:"expiration,omitempty"`
	ReadOnly         bool   `protobuf:"varint,6,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	UpdateReadOnly   bool   `protobuf:"varint,7,opt,name=update_read_only,json=updateReadOnly" json:"update_read_only,omitempty"`
}

func (m *UpdateLinkReq) Reset()                    { *m = UpdateLinkReq{} }
func (m *UpdateLinkReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateLinkReq) ProtoMessage()               {}
func (*UpdateLinkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *UpdateLinkReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UpdateLinkReq) GetUpdatePassword() bool {
	if m != nil {
		return m.UpdatePassword
	}
	return false
}

func (m *UpdateLinkReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UpdateLinkReq) GetUpdateExpiration() bool {
	if m != nil {
		return m.UpdateExpiration
	}
	return false
}

func (m *UpdateLinkReq) GetExpiration() uint64 {
	if m != nil {
		return m.Expiration
	}
	return 0
}

func (m *UpdateLinkReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *UpdateLinkReq) GetUpdateReadOnly() bool {
	if m != nil {
		return m.UpdateReadOnly
	}
	return false
}

type PublicLinkResponse struct {
	Status     StatusCode  `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	PublicLink *PublicLink `protobuf:"bytes,2,opt,name=publicLink" json:"publicLink,omitempty"`
}

func (m *PublicLinkResponse) Reset()                    { *m = PublicLinkResponse{} }
func (m *PublicLinkResponse) String() string            { return proto.CompactTextString(m) }
func (*PublicLinkResponse) ProtoMessage()               {}
func (*PublicLinkResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *PublicLinkResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *PublicLinkResponse) GetPublicLink() *PublicLink {
	if m != nil {
		return m.PublicLink
	}
	return nil
}

type PublicLink struct {
	Token     string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Path      string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Protected bool   `protobuf:"varint,3,opt,name=protected" json:"protected,omitempty"`
	Expires   uint64 `protobuf:"varint,5,opt,name=expires" json:"expires,omitempty"`
	ReadOnly  bool   `protobuf:"varint,6,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Mtime     uint64 `protobuf:"varint,8,opt,name=mtime" json:"mtime,omitempty"`
}

func (m *PublicLink) Reset()                    { *m = PublicLink{} }
func (m *PublicLink) String() string            { return proto.CompactTextString(m) }
func (*PublicLink) ProtoMessage()               {}
func (*PublicLink) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *PublicLink) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *PublicLink) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *PublicLink) GetProtected() bool {
	if m != nil {
		return m.Protected
	}
	return false
}

func (m *PublicLink) GetExpires() uint64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *PublicLink) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *PublicLink) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

type TokenReq struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *TokenReq) Reset()                    { *m = TokenReq{} }
func (m *TokenReq) String() string            { return proto.CompactTextString(m) }
func (*TokenReq) ProtoMessage()               {}
func (*TokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *TokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type FolderShareResponse struct {
	Status      StatusCode   `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	FolderShare *FolderShare `protobuf:"bytes,2,opt,name=folderShare" json:"folderShare,omitempty"`
}

func (m *FolderShareResponse) Reset()                    { *m = FolderShareResponse{} }
func (m *FolderShareResponse) String() string            { return proto.CompactTextString(m) }
func (*FolderShareResponse) ProtoMessage()               {}
func (*FolderShareResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *FolderShareResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *FolderShareResponse) GetFolderShare() *FolderShare {
	if m != nil {
		return m.FolderShare
	}
	return nil
}

type FolderShare struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Path        string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	OwnerId     string `protobuf:"bytes,3,opt,name=owner_id,json=ownerId" json:"owner_id,omitempty"`
	RecipientId string `protobuf:"bytes,4,opt,name=recipient_id,json=recipientId" json:"recipient_id,omitempty"`
	ReadOnly    bool   `protobuf:"varint,5,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Ctime       uint64 `protobuf:"varint,7,opt,name=ctime" json:"ctime,omitempty"`
	Mtime       uint64 `protobuf:"varint,8,opt,name=mtime" json:"mtime,omitempty"`
}

func (m *FolderShare) Reset()                    { *m = FolderShare{} }
func (m *FolderShare) String() string            { return proto.CompactTextString(m) }
func (*FolderShare) ProtoMessage()               {}
func (*FolderShare) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *FolderShare) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FolderShare) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FolderShare) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *FolderShare) GetRecipientId() string {
	if m != nil {
		return m.RecipientId
	}
	return ""
}

func (m *FolderShare) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *FolderShare) GetCtime() uint64 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *FolderShare) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

type ReceivedShareResponse struct {
	Status        StatusCode     `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	ReceivedShare *ReceivedShare `protobuf:"bytes,2,opt,name=receivedShare" json:"receivedShare,omitempty"`
}

func (m *ReceivedShareResponse) Reset()                    { *m = ReceivedShareResponse{} }
func (m *ReceivedShareResponse) String() string            { return proto.CompactTextString(m) }
func (*ReceivedShareResponse) ProtoMessage()               {}
func (*ReceivedShareResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *ReceivedShareResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *ReceivedShareResponse) GetReceivedShare() *ReceivedShare {
	if m != nil {
		return m.ReceivedShare
	}
	return nil
}

type ReceivedShare struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Path        string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	OwnerId     string `protobuf:"bytes,3,opt,name=owner_id,json=ownerId" json:"owner_id,omitempty"`
	RecipientId string `protobuf:"bytes,4,opt,name=recipient_id,json=recipientId" json:"recipient_id,omitempty"`
	ReadOnly    bool   `protobuf:"varint,5,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Mounted     bool   `protobuf:"varint,6,opt,name=mounted" json:"mounted,omitempty"`
	MountName   string `protobuf:"bytes,7,opt,name=mount_name,json=mountName" json:"mount_name,omitempty"`
	Ctime       uint64 `protobuf:"varint,8,opt,name=ctime" json:"ctime,omitempty"`
	Mtime       uint64 `protobuf:"varint,9,opt,name=mtime" json:"mtime,omitempty"`
}

func (m *ReceivedShare) Reset()                    { *m = ReceivedShare{} }
func (m *ReceivedShare) String() string            { return proto.CompactTextString(m) }
func (*ReceivedShare) ProtoMessage()               {}
func (*ReceivedShare) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *ReceivedShare) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ReceivedShare) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ReceivedShare) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *ReceivedShare) GetRecipientId() string {
	if m != nil {
		return m.RecipientId
	}
	return ""
}

func (m *ReceivedShare) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *ReceivedShare) GetMounted() bool {
	if m != nil {
		return m.Mounted
	}
	return false
}

func (m *ReceivedShare) GetMountName() string {
	if m != nil {
		return m.MountName
	}
	return ""
}

func (m *ReceivedShare) GetCtime() uint64 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *ReceivedShare) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

type NewFolderShareReq struct {
	Path      string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Recipient string `protobuf:"bytes,2,opt,name=recipient" json:"recipient,omitempty"`
	ReadOnly  bool   `protobuf:"varint,3,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
}

func (m *NewFolderShareReq) Reset()                    { *m = NewFolderShareReq{} }
func (m *NewFolderShareReq) String() string            { return proto.CompactTextString(m) }
func (*NewFolderShareReq) ProtoMessage()               {}
func (*NewFolderShareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *NewFolderShareReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *NewFolderShareReq) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *NewFolderShareReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type UpdateFolderShareReq struct {
	Id       string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ReadOnly bool   `protobuf:"varint,2,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
}

func (m *UpdateFolderShareReq) Reset()                    { *m = UpdateFolderShareReq{} }
func (m *UpdateFolderShareReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateFolderShareReq) ProtoMessage()               {}
func (*UpdateFolderShareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *UpdateFolderShareReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateFolderShareReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type UnshareFolderReq struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *UnshareFolderReq) Reset()                    { *m = UnshareFolderReq{} }
func (m *UnshareFolderReq) String() string            { return proto.CompactTextString(m) }
func (*UnshareFolderReq) ProtoMessage()               {}
func (*UnshareFolderReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *UnshareFolderReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ListFolderSharesReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *ListFolderSharesReq) Reset()                    { *m = ListFolderSharesReq{} }
func (m *ListFolderSharesReq) String() string            { return proto.CompactTextString(m) }
func (*ListFolderSharesReq) ProtoMessage()               {}
func (*ListFolderSharesReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *ListFolderSharesReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type ReceivedShareReq struct {
	ShareId string `protobuf:"bytes,1,opt,name=share_id,json=shareId" json:"share_id,omitempty"`
}

func (m *ReceivedShareReq) Reset()                    { *m = ReceivedShareReq{} }
func (m *ReceivedShareReq) String() string            { return proto.CompactTextString(m) }
func (*ReceivedShareReq) ProtoMessage()               {}
func (*ReceivedShareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *ReceivedShareReq) GetShareId() string {
	if m != nil {
		return m.ShareId
	}
	return ""
}

func init() {
	proto.RegisterType((*EmptyResponse)(nil), "api.EmptyResponse")
	proto.RegisterType((*EmptyReq)(nil), "api.EmptyReq")
	proto.RegisterType((*UserResponse)(nil), "api.UserResponse")
	proto.RegisterType((*User)(nil), "api.User")
	proto.RegisterType((*TxInfoResponse)(nil), "api.TxInfoResponse")
	proto.RegisterType((*TxInfo)(nil), "api.TxInfo")
	proto.RegisterType((*CreateTokenReq)(nil), "api.CreateTokenReq")
	proto.RegisterType((*TokenResponse)(nil), "api.TokenResponse")
	proto.RegisterType((*Token)(nil), "api.Token")
	proto.RegisterType((*VerifyTokenReq)(nil), "api.VerifyTokenReq")
	proto.RegisterType((*MetadataResponse)(nil), "api.MetadataResponse")
	proto.RegisterType((*Metadata)(nil), "api.Metadata")
	proto.RegisterType((*PathReq)(nil), "api.PathReq")
	proto.RegisterType((*MoveReq)(nil), "api.MoveReq")
	proto.RegisterType((*TxChunk)(nil), "api.TxChunk")
	proto.RegisterType((*WriteSummaryResponse)(nil), "api.WriteSummaryResponse")
	proto.RegisterType((*WriteSummary)(nil), "api.WriteSummary")
	proto.RegisterType((*TxEnd)(nil), "api.TxEnd")
	proto.RegisterType((*DataChunkResponse)(nil), "api.DataChunkResponse")
	proto.RegisterType((*DataChunk)(nil), "api.DataChunk")
	proto.RegisterType((*RevisionResponse)(nil), "api.RevisionResponse")
	proto.RegisterType((*Revision)(nil), "api.Revision")
	proto.RegisterType((*RevisionReq)(nil), "api.RevisionReq")
	proto.RegisterType((*RecycleEntryResponse)(nil), "api.RecycleEntryResponse")
	proto.RegisterType((*RecycleEntry)(nil), "api.RecycleEntry")
	proto.RegisterType((*RecycleEntryReq)(nil), "api.RecycleEntryReq")
	proto.RegisterType((*LinkPermissions)(nil), "api.LinkPermissions")
	proto.RegisterType((*NewLinkReq)(nil), "api.NewLinkReq")
	proto.RegisterType((*UpdateLinkReq)(nil), "api.UpdateLinkReq")
	proto.RegisterType((*PublicLinkResponse)(nil), "api.PublicLinkResponse")
	proto.RegisterType((*PublicLink)(nil), "api.PublicLink")
	proto.RegisterType((*TokenReq)(nil), "api.TokenReq")
	proto.RegisterType((*FolderShareResponse)(nil), "api.FolderShareResponse")
	proto.RegisterType((*FolderShare)(nil), "api.FolderShare")
	proto.RegisterType((*ReceivedShareResponse)(nil), "api.ReceivedShareResponse")
	proto.RegisterType((*ReceivedShare)(nil), "api.ReceivedShare")
	proto.RegisterType((*NewFolderShareReq)(nil), "api.NewFolderShareReq")
	proto.RegisterType((*UpdateFolderShareReq)(nil), "api.UpdateFolderShareReq")
	proto.RegisterType((*UnshareFolderReq)(nil), "api.UnshareFolderReq")
	proto.RegisterType((*ListFolderSharesReq)(nil), "api.ListFolderSharesReq")
	proto.RegisterType((*ReceivedShareReq)(nil), "api.ReceivedShareReq")
	proto.RegisterEnum("api.StatusCode", StatusCode_name, StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Auth service

type AuthClient interface {
	CreateToken(ctx context.Context, in *CreateTokenReq, opts ...grpc.CallOption) (*TokenResponse, error)
	VerifyToken(ctx context.Context, in *VerifyTokenReq, opts ...grpc.CallOption) (*UserResponse, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) CreateToken(ctx context.Context, in *CreateTokenReq, opts ...grpc.CallOption) (*TokenResponse, error) {
	out := new(TokenResponse)
	err := grpc.Invoke(ctx, "/api.Auth/CreateToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) VerifyToken(ctx context.Context, in *VerifyTokenReq, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := grpc.Invoke(ctx, "/api.Auth/VerifyToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	CreateToken(context.Context, *CreateTokenReq) (*TokenResponse, error)
	VerifyToken(context.Context, *VerifyTokenReq) (*UserResponse, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_CreateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).CreateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Auth/CreateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).CreateToken(ctx, req.(*CreateTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_VerifyToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).VerifyToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Auth/VerifyToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).VerifyToken(ctx, req.(*VerifyTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateToken",
			Handler:    _Auth_CreateToken_Handler,
		},
		{
			MethodName: "VerifyToken",
			Handler:    _Auth_VerifyToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for Storage service

type StorageClient interface {
	CreateDir(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	Delete(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	Move(ctx context.Context, in *MoveReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	Inspect(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*MetadataResponse, error)
	ListFolder(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListFolderClient, error)
	StartWriteTx(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*TxInfoResponse, error)
	WriteChunk(ctx context.Context, opts ...grpc.CallOption) (Storage_WriteChunkClient, error)
	FinishWriteTx(ctx context.Context, in *TxEnd, opts ...grpc.CallOption) (*EmptyResponse, error)
	ReadFile(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ReadFileClient, error)
	ListRevisions(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRevisionsClient, error)
	ReadRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (Storage_ReadRevisionClient, error)
	RestoreRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	ListRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRecycleClient, error)
	RestoreRecycleEntry(ctx context.Context, in *RecycleEntryReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	EmptyRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error)
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) CreateDir(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/CreateDir", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Delete(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Move(ctx context.Context, in *MoveReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/Move", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Inspect(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*MetadataResponse, error) {
	out := new(MetadataResponse)
	err := grpc.Invoke(ctx, "/api.Storage/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ListFolder(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListFolderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[0], c.cc, "/api.Storage/ListFolder", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageListFolderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ListFolderClient interface {
	Recv() (*MetadataResponse, error)
	grpc.ClientStream
}

type storageListFolderClient struct {
	grpc.ClientStream
}

func (x *storageListFolderClient) Recv() (*MetadataResponse, error) {
	m := new(MetadataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) StartWriteTx(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*TxInfoResponse, error) {
	out := new(TxInfoResponse)
	err := grpc.Invoke(ctx, "/api.Storage/StartWriteTx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) WriteChunk(ctx context.Context, opts ...grpc.CallOption) (Storage_WriteChunkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[1], c.cc, "/api.Storage/WriteChunk", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageWriteChunkClient{stream}
	return x, nil
}

type Storage_WriteChunkClient interface {
	Send(*TxChunk) error
	CloseAndRecv() (*WriteSummaryResponse, error)
	grpc.ClientStream
}

type storageWriteChunkClient struct {
	grpc.ClientStream
}

func (x *storageWriteChunkClient) Send(m *TxChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *storageWriteChunkClient) CloseAndRecv() (*WriteSummaryResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteSummaryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) FinishWriteTx(ctx context.Context, in *TxEnd, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/FinishWriteTx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ReadFile(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ReadFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[2], c.cc, "/api.Storage/ReadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageReadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ReadFileClient interface {
	Recv() (*DataChunkResponse, error)
	grpc.ClientStream
}

type storageReadFileClient struct {
	grpc.ClientStream
}

func (x *storageReadFileClient) Recv() (*DataChunkResponse, error) {
	m := new(DataChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) ListRevisions(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRevisionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[3], c.cc, "/api.Storage/ListRevisions", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageListRevisionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ListRevisionsClient interface {
	Recv() (*RevisionResponse, error)
	grpc.ClientStream
}

type storageListRevisionsClient struct {
	grpc.ClientStream
}

func (x *storageListRevisionsClient) Recv() (*RevisionResponse, error) {
	m := new(RevisionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) ReadRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (Storage_ReadRevisionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[4], c.cc, "/api.Storage/ReadRevision", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageReadRevisionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ReadRevisionClient interface {
	Recv() (*DataChunkResponse, error)
	grpc.ClientStream
}

type storageReadRevisionClient struct {
	grpc.ClientStream
}

func (x *storageReadRevisionClient) Recv() (*DataChunkResponse, error) {
	m := new(DataChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) RestoreRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/RestoreRevision", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ListRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRecycleClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[5], c.cc, "/api.Storage/ListRecycle", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageListRecycleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ListRecycleClient interface {
	Recv() (*RecycleEntryResponse, error)
	grpc.ClientStream
}

type storageListRecycleClient struct {
	grpc.ClientStream
}

func (x *storageListRecycleClient) Recv() (*RecycleEntryResponse, error) {
	m := new(RecycleEntryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) RestoreRecycleEntry(ctx context.Context, in *RecycleEntryReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/RestoreRecycleEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) EmptyRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/EmptyRecycle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Storage service

type StorageServer interface {
	CreateDir(context.Context, *PathReq) (*EmptyResponse, error)
	Delete(context.Context, *PathReq) (*EmptyResponse, error)
	Move(context.Context, *MoveReq) (*EmptyResponse, error)
	Inspect(context.Context, *PathReq) (*MetadataResponse, error)
	ListFolder(*PathReq, Storage_ListFolderServer) error
	StartWriteTx(context.Context, *EmptyReq) (*TxInfoResponse, error)
	WriteChunk(Storage_WriteChunkServer) error
	FinishWriteTx(context.Context, *TxEnd) (*EmptyResponse, error)
	ReadFile(*PathReq, Storage_ReadFileServer) error
	ListRevisions(*PathReq, Storage_ListRevisionsServer) error
	ReadRevision(*RevisionReq, Storage_ReadRevisionServer) error
	RestoreRevision(context.Context, *RevisionReq) (*EmptyResponse, error)
	ListRecycle(*PathReq, Storage_ListRecycleServer) error
	RestoreRecycleEntry(context.Context, *RecycleEntryReq) (*EmptyResponse, error)
	EmptyRecycle(context.Context, *PathReq) (*EmptyResponse, error)
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_CreateDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).CreateDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/CreateDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).CreateDir(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Delete(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Move(ctx, req.(*MoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Inspect(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ListFolder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ListFolder(m, &storageListFolderServer{stream})
}

type Storage_ListFolderServer interface {
	Send(*MetadataResponse) error
	grpc.ServerStream
}

type storageListFolderServer struct {
	grpc.ServerStream
}

func (x *storageListFolderServer) Send(m *MetadataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_StartWriteTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).StartWriteTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/StartWriteTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).StartWriteTx(ctx, req.(*EmptyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_WriteChunk_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageServer).WriteChunk(&storageWriteChunkServer{stream})
}

type Storage_WriteChunkServer interface {
	SendAndClose(*WriteSummaryResponse) error
	Recv() (*TxChunk, error)
	grpc.ServerStream
}

type storageWriteChunkServer struct {
	grpc.ServerStream
}

func (x *storageWriteChunkServer) SendAndClose(m *WriteSummaryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *storageWriteChunkServer) Recv() (*TxChunk, error) {
	m := new(TxChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Storage_FinishWriteTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxEnd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).FinishWriteTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/FinishWriteTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).FinishWriteTx(ctx, req.(*TxEnd))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ReadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ReadFile(m, &storageReadFileServer{stream})
}

type Storage_ReadFileServer interface {
	Send(*DataChunkResponse) error
	grpc.ServerStream
}

type storageReadFileServer struct {
	grpc.ServerStream
}

func (x *storageReadFileServer) Send(m *DataChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_ListRevisions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ListRevisions(m, &storageListRevisionsServer{stream})
}

type Storage_ListRevisionsServer interface {
	Send(*RevisionResponse) error
	grpc.ServerStream
}

type storageListRevisionsServer struct {
	grpc.ServerStream
}

func (x *storageListRevisionsServer) Send(m *RevisionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_ReadRevision_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RevisionReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ReadRevision(m, &storageReadRevisionServer{stream})
}

type Storage_ReadRevisionServer interface {
	Send(*DataChunkResponse) error
	grpc.ServerStream
}

type storageReadRevisionServer struct {
	grpc.ServerStream
}

func (x *storageReadRevisionServer) Send(m *DataChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_RestoreRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevisionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).RestoreRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/RestoreRevision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).RestoreRevision(ctx, req.(*RevisionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ListRecycle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ListRecycle(m, &storageListRecycleServer{stream})
}

type Storage_ListRecycleServer interface {
	Send(*RecycleEntryResponse) error
	grpc.ServerStream
}

type storageListRecycleServer struct {
	grpc.ServerStream
}

func (x *storageListRecycleServer) Send(m *RecycleEntryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_RestoreRecycleEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecycleEntryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).RestoreRecycleEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/RestoreRecycleEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).RestoreRecycleEntry(ctx, req.(*RecycleEntryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_EmptyRecycle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).EmptyRecycle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/EmptyRecycle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).EmptyRecycle(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDir",
			Handler:    _Storage_CreateDir_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Storage_Delete_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _Storage_Move_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _Storage_Inspect_Handler,
		},
		{
			MethodName: "StartWriteTx",
			Handler:    _Storage_StartWriteTx_Handler,
		},
		{
			MethodName: "FinishWriteTx",
			Handler:    _Storage_FinishWriteTx_Handler,
		},
		{
			MethodName: "RestoreRevision",
			Handler:    _Storage_RestoreRevision_Handler,
		},
		{
			MethodName: "RestoreRecycleEntry",
			Handler:    _Storage_RestoreRecycleEntry_Handler,
		},
		{
			MethodName: "EmptyRecycle",
			Handler:    _Storage_EmptyRecycle_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListFolder",
			Handler:       _Storage_ListFolder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteChunk",
			Handler:       _Storage_WriteChunk_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadFile",
			Handler:       _Storage_ReadFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListRevisions",
			Handler:       _Storage_ListRevisions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReadRevision",
			Handler:       _Storage_ReadRevision_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListRecycle",
			Handler:       _Storage_ListRecycle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// Client API for Share service

type ShareClient interface {
	CreatePublicLink(ctx context.Context, in *NewLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
	UpdatePublicLink(ctx context.Context, in *UpdateLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
	InspectPublicLink(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
	RevokePublicLink(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	ListPublicLinks(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (Share_ListPublicLinksClient, error)
	AddFolderShare(ctx context.Context, in *NewFolderShareReq, opts ...grpc.CallOption) (*FolderShareResponse, error)
	UpdateFolderShare(ctx context.Context, in *UpdateFolderShareReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	ListFolderShares(ctx context.Context, in *ListFolderSharesReq, opts ...grpc.CallOption) (Share_ListFolderSharesClient, error)
	UnshareFolder(ctx context.Context, in *UnshareFolderReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	ListReceivedShares(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (Share_ListReceivedSharesClient, error)
	MountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	UnmountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error)
}

type shareClient struct {
	cc *grpc.ClientConn
}

func NewShareClient(cc *grpc.ClientConn) ShareClient {
	return &shareClient{cc}
}

func (c *shareClient) CreatePublicLink(ctx context.Context, in *NewLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Share/CreatePublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdatePublicLink(ctx context.Context, in *UpdateLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Share/UpdatePublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) InspectPublicLink(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Share/InspectPublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) RevokePublicLink(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/RevokePublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ListPublicLinks(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (Share_ListPublicLinksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Share_serviceDesc.Streams[0], c.cc, "/api.Share/ListPublicLinks", opts...)
	if err != nil {
		return nil, err
	}
	x := &shareListPublicLinksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Share_ListPublicLinksClient interface {
	Recv() (*PublicLinkResponse, error)
	grpc.ClientStream
}

type shareListPublicLinksClient struct {
	grpc.ClientStream
}

func (x *shareListPublicLinksClient) Recv() (*PublicLinkResponse, error) {
	m := new(PublicLinkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shareClient) AddFolderShare(ctx context.Context, in *NewFolderShareReq, opts ...grpc.CallOption) (*FolderShareResponse, error) {
	out := new(FolderShareResponse)
	err := grpc.Invoke(ctx, "/api.Share/AddFolderShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdateFolderShare(ctx context.Context, in *UpdateFolderShareReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/UpdateFolderShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ListFolderShares(ctx context.Context, in *ListFolderSharesReq, opts ...grpc.CallOption) (Share_ListFolderSharesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Share_serviceDesc.Streams[1], c.cc, "/api.Share/ListFolderShares", opts...)
	if err != nil {
		return nil, err
	}
	x := &shareListFolderSharesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Share_ListFolderSharesClient interface {
	Recv() (*FolderShareResponse, error)
	grpc.ClientStream
}

type shareListFolderSharesClient struct {
	grpc.ClientStream
}

func (x *shareListFolderSharesClient) Recv() (*FolderShareResponse, error) {
	m := new(FolderShareResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shareClient) UnshareFolder(ctx context.Context, in *UnshareFolderReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/UnshareFolder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ListReceivedShares(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (Share_ListReceivedSharesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Share_serviceDesc.Streams[2], c.cc, "/api.Share/ListReceivedShares", opts...)
	if err != nil {
		return nil, err
	}
	x := &shareListReceivedSharesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Share_ListReceivedSharesClient interface {
	Recv() (*ReceivedShareResponse, error)
	grpc.ClientStream
}

type shareListReceivedSharesClient struct {
	grpc.ClientStream
}

func (x *shareListReceivedSharesClient) Recv() (*ReceivedShareResponse, error) {
	m := new(ReceivedShareResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shareClient) MountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/MountReceivedShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UnmountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/UnmountReceivedShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Share service

type ShareServer interface {
	CreatePublicLink(context.Context, *NewLinkReq) (*PublicLinkResponse, error)
	UpdatePublicLink(context.Context, *UpdateLinkReq) (*PublicLinkResponse, error)
	InspectPublicLink(context.Context, *TokenReq) (*PublicLinkResponse, error)
	RevokePublicLink(context.Context, *TokenReq) (*EmptyResponse, error)
	ListPublicLinks(*EmptyReq, Share_ListPublicLinksServer) error
	AddFolderShare(context.Context, *NewFolderShareReq) (*FolderShareResponse, error)
	UpdateFolderShare(context.Context, *UpdateFolderShareReq) (*EmptyResponse, error)
	ListFolderShares(*ListFolderSharesReq, Share_ListFolderSharesServer) error
	UnshareFolder(context.Context, *UnshareFolderReq) (*EmptyResponse, error)
	ListReceivedShares(*EmptyReq, Share_ListReceivedSharesServer) error
	MountReceivedShare(context.Context, *ReceivedShareReq) (*EmptyResponse, error)
	UnmountReceivedShare(context.Context, *ReceivedShareReq) (*EmptyResponse, error)
}

func RegisterShareServer(s *grpc.Server, srv ShareServer) {
	s.RegisterService(&_Share_serviceDesc, srv)
}

func _Share_CreatePublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewLinkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).CreatePublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/CreatePublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).CreatePublicLink(ctx, req.(*NewLinkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdatePublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLinkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdatePublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UpdatePublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdatePublicLink(ctx, req.(*UpdateLinkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_InspectPublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).InspectPublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/InspectPublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).InspectPublicLink(ctx, req.(*TokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_RevokePublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).RevokePublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/RevokePublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).RevokePublicLink(ctx, req.(*TokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ListPublicLinks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EmptyReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShareServer).ListPublicLinks(m, &shareListPublicLinksServer{stream})
}

type Share_ListPublicLinksServer interface {
	Send(*PublicLinkResponse) error
	grpc.ServerStream
}

type shareListPublicLinksServer struct {
	grpc.ServerStream
}

func (x *shareListPublicLinksServer) Send(m *PublicLinkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Share_AddFolderShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewFolderShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).AddFolderShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/AddFolderShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).AddFolderShare(ctx, req.(*NewFolderShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdateFolderShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFolderShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdateFolderShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UpdateFolderShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdateFolderShare(ctx, req.(*UpdateFolderShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ListFolderShares_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListFolderSharesReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShareServer).ListFolderShares(m, &shareListFolderSharesServer{stream})
}

type Share_ListFolderSharesServer interface {
	Send(*FolderShareResponse) error
	grpc.ServerStream
}

type shareListFolderSharesServer struct {
	grpc.ServerStream
}

func (x *shareListFolderSharesServer) Send(m *FolderShareResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Share_UnshareFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnshareFolderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UnshareFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UnshareFolder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UnshareFolder(ctx, req.(*UnshareFolderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ListReceivedShares_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EmptyReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShareServer).ListReceivedShares(m, &shareListReceivedSharesServer{stream})
}

type Share_ListReceivedSharesServer interface {
	Send(*ReceivedShareResponse) error
	grpc.ServerStream
}

type shareListReceivedSharesServer struct {
	grpc.ServerStream
}

func (x *shareListReceivedSharesServer) Send(m *ReceivedShareResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Share_MountReceivedShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceivedShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).MountReceivedShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/MountReceivedShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).MountReceivedShare(ctx, req.(*ReceivedShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UnmountReceivedShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceivedShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UnmountReceivedShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UnmountReceivedShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UnmountReceivedShare(ctx, req.(*ReceivedShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Share_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Share",
	HandlerType: (*ShareServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePublicLink",
			Handler:    _Share_CreatePublicLink_Handler,
		},
		{
			MethodName: "UpdatePublicLink",
			Handler:    _Share_UpdatePublicLink_Handler,
		},
		{
			MethodName: "InspectPublicLink",
			Handler:    _Share_InspectPublicLink_Handler,
		},
		{
			MethodName: "RevokePublicLink",
			Handler:    _Share_RevokePublicLink_Handler,
		},
		{
			MethodName: "AddFolderShare",
			Handler:    _Share_AddFolderShare_Handler,
		},
		{
			MethodName: "UpdateFolderShare",
			Handler:    _Share_UpdateFolderShare_Handler,
		},
		{
			MethodName: "UnshareFolder",
			Handler:    _Share_UnshareFolder_Handler,
		},
		{
			MethodName: "MountReceivedShare",
			Handler:    _Share_MountReceivedShare_Handler,
		},
		{
			MethodName: "UnmountReceivedShare",
			Handler:    _Share_UnmountReceivedShare_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListPublicLinks",
			Handler:       _Share_ListPublicLinks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListFolderShares",
			Handler:       _Share_ListFolderShares_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListReceivedShares",
			Handler:       _Share_ListReceivedShares_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// Client API for Preview service

type PreviewClient interface {
	ReadPreview(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Preview_ReadPreviewClient, error)
}

type previewClient struct {
	cc *grpc.ClientConn
}

func NewPreviewClient(cc *grpc.ClientConn) PreviewClient {
	return &previewClient{cc}
}

func (c *previewClient) ReadPreview(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Preview_ReadPreviewClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Preview_serviceDesc.Streams[0], c.cc, "/api.Preview/ReadPreview", opts...)
	if err != nil {
		return nil, err
	}
	x := &previewReadPreviewClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Preview_ReadPreviewClient interface {
	Recv() (*DataChunkResponse, error)
	grpc.ClientStream
}

type previewReadPreviewClient struct {
	grpc.ClientStream
}

func (x *previewReadPreviewClient) Recv() (*DataChunkResponse, error) {
	m := new(DataChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Preview service

type PreviewServer interface {
	ReadPreview(*PathReq, Preview_ReadPreviewServer) error
}

func RegisterPreviewServer(s *grpc.Server, srv PreviewServer) {
	s.RegisterService(&_Preview_serviceDesc, srv)
}

func _Preview_ReadPreview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PreviewServer).ReadPreview(m, &previewReadPreviewServer{stream})
}

type Preview_ReadPreviewServer interface {
	Send(*DataChunkResponse) error
	grpc.ServerStream
}

type previewReadPreviewServer struct {
	grpc.ServerStream
}

func (x *previewReadPreviewServer) Send(m *DataChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Preview_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Preview",
	HandlerType: (*PreviewServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadPreview",
			Handler:       _Preview_ReadPreview_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1918 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x5b, 0x73, 0xdb, 0xc6,
	0x15, 0x0e, 0x78, 0xc7, 0xe1, 0xc5, 0xe0, 0x4a, 0x72, 0x28, 0xda, 0x6a, 0xd5, 0xcd, 0x4c, 0xa3,
	0xa4, 0x69, 0xe2, 0xb2, 0xc9, 0xc4, 0x49, 0xeb, 0x76, 0x18, 0x91, 0x4e, 0x59, 0x49, 0x24, 0x0b,
	0x92, 0x4e, 0xda, 0x87, 0x62, 0x60, 0x62, 0x65, 0xa1, 0x22, 0x01, 0x1a, 0x58, 0xea, 0xe2, 0x9f,
	0x92, 0xb7, 0xce, 0xf4, 0x47, 0xf4, 0xa5, 0xfd, 0x53, 0x7d, 0xef, 0x74, 0xf6, 0x02, 0x62, 0x41,
	0x81, 0xac, 0xe5, 0x3e, 0xf4, 0x89, 0xd8, 0xb3, 0xe7, 0xfa, 0xed, 0x9e, 0xb3, 0xe7, 0x10, 0x74,
	0x7b, 0xe1, 0x7e, 0xba, 0x08, 0x7c, 0xea, 0xa3, 0xac, 0xbd, 0x70, 0xf1, 0x53, 0xa8, 0x76, 0xe7,
	0x0b, 0x7a, 0x6b, 0x92, 0x70, 0xe1, 0x7b, 0x21, 0x41, 0x1f, 0x42, 0x21, 0xa4, 0x36, 0x5d, 0x86,
	0x0d, 0xed, 0x50, 0x3b, 0xaa, 0xb5, 0x1e, 0x7c, 0xca, 0x24, 0x46, 0x9c, 0x74, 0xec, 0x3b, 0xc4,
	0x94, 0xdb, 0x18, 0xa0, 0x24, 0x25, 0x5f, 0xe3, 0x17, 0x50, 0x99, 0x84, 0x24, 0xb8, 0xb7, 0x12,
	0x74, 0x00, 0xb9, 0x65, 0x48, 0x82, 0x46, 0xe6, 0x50, 0x3b, 0x2a, 0xb7, 0x74, 0xce, 0xc6, 0x35,
	0x71, 0x32, 0x7e, 0x06, 0x39, 0xb6, 0x42, 0x07, 0x00, 0xf6, 0x74, 0xea, 0x2f, 0x3d, 0x6a, 0xb9,
	0x0e, 0xd7, 0xa9, 0x9b, 0xba, 0xa4, 0xf4, 0x1c, 0xf4, 0x10, 0x0a, 0xaf, 0x02, 0x7f, 0xb9, 0x08,
	0x1b, 0x99, 0xc3, 0xec, 0x91, 0x6e, 0xca, 0x15, 0xfe, 0x33, 0xd4, 0xc6, 0x37, 0x3d, 0xef, 0xdc,
	0xbf, 0xbf, 0x63, 0x1f, 0x40, 0x81, 0x72, 0x51, 0xe9, 0x5a, 0x99, 0x33, 0x4a, 0x6d, 0x72, 0x0b,
	0x1f, 0x40, 0x41, 0x50, 0xd0, 0x0e, 0xe4, 0xe9, 0x4d, 0xec, 0x5b, 0x8e, 0xde, 0xf4, 0x1c, 0x6c,
	0x42, 0xed, 0x38, 0x20, 0x36, 0x25, 0x63, 0xff, 0x92, 0x78, 0x26, 0x79, 0x8d, 0x1e, 0x81, 0x3e,
	0x9d, 0xb9, 0x44, 0x0d, 0xa3, 0x24, 0x08, 0x3d, 0x07, 0x7d, 0x00, 0x55, 0xb9, 0x19, 0x92, 0x69,
	0x40, 0x28, 0xb7, 0xac, 0x9b, 0x15, 0x41, 0x1c, 0x71, 0x1a, 0xfe, 0x13, 0x54, 0xa5, 0xb6, 0xfb,
	0x46, 0x74, 0x08, 0x79, 0xca, 0x24, 0x65, 0x40, 0x20, 0x02, 0xe2, 0xba, 0xc4, 0x06, 0x3e, 0x80,
	0x3c, 0x5f, 0xa3, 0xdd, 0x88, 0x55, 0xb8, 0x28, 0xb7, 0x7f, 0x0a, 0xb5, 0x17, 0x24, 0x70, 0xcf,
	0x6f, 0x57, 0xe1, 0xa4, 0xf3, 0x9d, 0x83, 0x71, 0x46, 0xa8, 0xed, 0xd8, 0xd4, 0xbe, 0xbf, 0x97,
	0x1f, 0x41, 0x69, 0x2e, 0x85, 0xa5, 0xa3, 0x55, 0xce, 0xba, 0xd2, 0xb8, 0xda, 0xc6, 0xff, 0xd4,
	0xa0, 0x14, 0x91, 0x51, 0x0d, 0x32, 0x2b, 0x48, 0x33, 0xae, 0x83, 0x10, 0xe4, 0x16, 0x36, 0xbd,
	0x90, 0x18, 0xf2, 0x6f, 0x46, 0x0b, 0xdd, 0x37, 0xa4, 0x91, 0x3d, 0xd4, 0x8e, 0x72, 0x26, 0xff,
	0x66, 0x21, 0xcc, 0xa9, 0x3b, 0x27, 0x8d, 0x1c, 0x27, 0x8a, 0x05, 0xda, 0x83, 0x82, 0x1b, 0x5a,
	0x8e, 0x1b, 0x34, 0xf2, 0x87, 0xda, 0x51, 0xc9, 0xcc, 0xbb, 0x61, 0xc7, 0x0d, 0x98, 0x02, 0x42,
	0xed, 0x57, 0x8d, 0x82, 0x50, 0xca, 0xbe, 0x51, 0x13, 0x4a, 0xd3, 0x0b, 0x32, 0xbd, 0x0c, 0x97,
	0xf3, 0x46, 0x51, 0x9e, 0xa8, 0x5c, 0xb3, 0x6b, 0xeb, 0x90, 0x80, 0x9c, 0x5b, 0xdc, 0x95, 0x92,
	0xb8, 0xb6, 0x9c, 0x32, 0xb4, 0xe9, 0x05, 0x3e, 0x80, 0x22, 0xfb, 0x65, 0x48, 0x46, 0xee, 0x6a,
	0xb1, 0xbb, 0xf8, 0xb7, 0x50, 0x3c, 0xf3, 0xaf, 0x08, 0xdb, 0xde, 0x87, 0x92, 0x3f, 0x73, 0x2c,
	0x85, 0xa5, 0xe8, 0xcf, 0x1c, 0x26, 0xcc, 0xb6, 0x3c, 0x72, 0x6d, 0x29, 0xc1, 0x16, 0x3d, 0x72,
	0xcd, 0xf5, 0xbf, 0x84, 0xe2, 0xf8, 0xe6, 0xf8, 0x62, 0xe9, 0x5d, 0xa6, 0xde, 0x4f, 0x96, 0x36,
	0x33, 0xe2, 0xbd, 0x92, 0x82, 0x39, 0x53, 0xae, 0x18, 0xdd, 0x3f, 0x3f, 0x0f, 0x09, 0x95, 0x48,
	0xc9, 0x15, 0x73, 0x92, 0x9f, 0x0b, 0x83, 0xaa, 0x62, 0xf2, 0x6f, 0x7c, 0x05, 0xbb, 0xdf, 0x05,
	0x2e, 0x25, 0xa3, 0xe5, 0x7c, 0x6e, 0x07, 0xf7, 0x2f, 0x23, 0xe8, 0x0b, 0xa8, 0x5c, 0x2b, 0x0a,
	0xe4, 0xa1, 0xd7, 0x39, 0x7b, 0x42, 0x73, 0x82, 0x0d, 0x7f, 0x0b, 0x15, 0x75, 0x17, 0x35, 0xa0,
	0xe8, 0x4d, 0x59, 0xa8, 0xc2, 0x60, 0xce, 0x8c, 0x96, 0xec, 0x10, 0xa8, 0x4f, 0xed, 0x99, 0xc5,
	0xcf, 0x5e, 0x44, 0xaa, 0x73, 0xca, 0xc8, 0x7d, 0x43, 0xf0, 0x29, 0xe4, 0xc7, 0x37, 0x5d, 0xcf,
	0x49, 0x87, 0x28, 0xed, 0x1a, 0xa9, 0x27, 0x9e, 0x4d, 0x9e, 0x38, 0xfe, 0x0b, 0xd4, 0x3b, 0x36,
	0xb5, 0x39, 0xe8, 0xf7, 0xc7, 0xe2, 0x13, 0xd0, 0x9d, 0x48, 0x5a, 0x02, 0x51, 0xe3, 0xbc, 0xb1,
	0xce, 0x98, 0x01, 0x0f, 0x40, 0x5f, 0xd1, 0x95, 0xb3, 0xd4, 0x36, 0x9c, 0x65, 0x26, 0xf5, 0x2c,
	0xb3, 0xca, 0x59, 0x9e, 0x83, 0x61, 0x92, 0x2b, 0x37, 0x74, 0x7d, 0xef, 0x9d, 0x12, 0x37, 0x90,
	0xc2, 0x89, 0xc4, 0x5d, 0x69, 0x5c, 0x6d, 0x63, 0x07, 0x4a, 0x11, 0x15, 0xbd, 0x0f, 0xc5, 0x80,
	0x5c, 0x59, 0x97, 0xe4, 0x56, 0xe2, 0x5e, 0x08, 0xc8, 0xd5, 0x09, 0xb9, 0x5d, 0x25, 0x6b, 0x26,
	0x2d, 0x59, 0xb3, 0xe9, 0xc9, 0x9a, 0x53, 0x92, 0x15, 0x7f, 0x0d, 0xe5, 0x38, 0x9a, 0xd4, 0x0c,
	0x53, 0x8d, 0x67, 0x54, 0xe3, 0xec, 0x56, 0x9b, 0x64, 0x7a, 0x3b, 0x9d, 0x91, 0xae, 0x47, 0xdf,
	0xf1, 0x56, 0x07, 0x8a, 0x82, 0xc4, 0xad, 0x4e, 0x68, 0x4e, 0xb0, 0xe1, 0x1f, 0x34, 0xa8, 0xa8,
	0xdb, 0xe8, 0x27, 0x4c, 0x4f, 0x48, 0xfd, 0x80, 0xa8, 0xc9, 0x5f, 0x96, 0x34, 0x5e, 0x00, 0x7e,
	0x0c, 0xd1, 0x52, 0x09, 0x04, 0x24, 0x49, 0x45, 0x52, 0x2d, 0x7b, 0x8f, 0x40, 0x77, 0xc8, 0xcc,
	0x52, 0x4b, 0x5f, 0xc9, 0x21, 0xb3, 0xb3, 0x2d, 0xd5, 0x0f, 0xb7, 0xe0, 0x41, 0x12, 0x94, 0xd7,
	0xeb, 0xb6, 0xb5, 0x75, 0xdb, 0xf8, 0x57, 0xf0, 0xe0, 0xd4, 0xf5, 0x2e, 0x87, 0x24, 0x98, 0xbb,
	0x21, 0x3b, 0x8a, 0x90, 0xb9, 0x13, 0x10, 0x5b, 0xa4, 0x59, 0xc9, 0xe4, 0xdf, 0xec, 0x60, 0x79,
	0x76, 0x73, 0xef, 0x4b, 0xa6, 0x58, 0xe0, 0x10, 0xa0, 0x4f, 0xae, 0x99, 0xfc, 0xa6, 0x03, 0x7c,
	0x04, 0x3a, 0x93, 0xb7, 0x7c, 0x6f, 0x76, 0x2b, 0x65, 0x4b, 0x8c, 0x30, 0xf0, 0x66, 0xb7, 0x2c,
	0x4f, 0x17, 0x76, 0x18, 0x5e, 0xfb, 0x81, 0x13, 0xe5, 0x69, 0xb4, 0x66, 0xe5, 0x82, 0xdc, 0x2c,
	0xdc, 0x80, 0x84, 0x32, 0xfa, 0x68, 0x89, 0xff, 0xad, 0x41, 0x75, 0xb2, 0x70, 0x6c, 0x4a, 0x22,
	0xc3, 0xa9, 0xaf, 0x1c, 0xfa, 0x10, 0x1e, 0x2c, 0x39, 0x9b, 0xb5, 0x32, 0x22, 0x1c, 0xa8, 0x09,
	0xf2, 0x30, 0x32, 0xb5, 0xcd, 0x8d, 0x9f, 0x41, 0x5d, 0x2a, 0xe1, 0xe6, 0x6d, 0xca, 0xb2, 0x47,
	0xdc, 0x62, 0x43, 0x6c, 0x74, 0x57, 0x74, 0xf4, 0x23, 0x00, 0x85, 0x2b, 0xcf, 0xdd, 0x56, 0x28,
	0x49, 0x30, 0x0a, 0x6b, 0x60, 0x1c, 0x81, 0x54, 0x68, 0xc5, 0x3c, 0x45, 0xd5, 0x5f, 0x53, 0x72,
	0x62, 0x0f, 0xd0, 0x70, 0xf9, 0x72, 0xe6, 0x4e, 0x45, 0xfc, 0xf7, 0xbd, 0xf9, 0x9f, 0x01, 0x2c,
	0x56, 0xe2, 0xf2, 0xde, 0x0b, 0x66, 0x45, 0xab, 0xc2, 0x82, 0xff, 0xaa, 0x01, 0xc4, 0x5b, 0x1b,
	0xd0, 0x4e, 0xab, 0xc3, 0x8f, 0x41, 0x67, 0x8d, 0x2c, 0x99, 0x52, 0x22, 0x90, 0x2d, 0x99, 0x31,
	0x41, 0x3d, 0xe1, 0x7c, 0xe2, 0x84, 0xb7, 0xe3, 0xb4, 0x2a, 0x31, 0x25, 0xa5, 0xc4, 0xe0, 0x43,
	0x28, 0xfd, 0x97, 0xa6, 0x27, 0x80, 0x9d, 0xe7, 0xfe, 0xcc, 0x21, 0xc1, 0xe8, 0xc2, 0x0e, 0xc8,
	0xfd, 0x61, 0x6b, 0x41, 0xf9, 0x3c, 0x96, 0x97, 0xb8, 0x19, 0x9c, 0x5b, 0xd5, 0xab, 0x32, 0xe1,
	0xbf, 0x6b, 0x50, 0x56, 0x36, 0xdf, 0xaa, 0x07, 0x62, 0x9d, 0xc4, 0xb5, 0x47, 0x02, 0xf6, 0xd0,
	0x65, 0x65, 0x27, 0xc1, 0xd6, 0x3d, 0x47, 0xd4, 0x9a, 0xa9, 0xbb, 0x88, 0xfa, 0xd3, 0x5c, 0x54,
	0x6b, 0x24, 0xad, 0xe7, 0x24, 0xa1, 0xcb, 0xdf, 0x85, 0x6e, 0xca, 0xa1, 0x2b, 0x0a, 0xe8, 0xf8,
	0x62, 0x03, 0xa0, 0x6f, 0x60, 0xcf, 0x24, 0x53, 0xe2, 0x5e, 0x11, 0xe7, 0x1d, 0x01, 0x7b, 0x0a,
	0xd5, 0x40, 0xd5, 0x20, 0x21, 0x43, 0x51, 0x89, 0x55, 0x74, 0x27, 0x19, 0xf1, 0xbf, 0x34, 0xa8,
	0x26, 0x18, 0xfe, 0xdf, 0xc0, 0x35, 0xa0, 0x38, 0x67, 0x93, 0x0c, 0x71, 0xe4, 0x75, 0x8c, 0x96,
	0xac, 0x77, 0xe1, 0x9f, 0x96, 0x67, 0x4b, 0x5c, 0x75, 0x53, 0xe7, 0x94, 0xbe, 0x2d, 0xb0, 0x9d,
	0xaa, 0xd8, 0xae, 0x21, 0xae, 0xab, 0x88, 0xbf, 0x84, 0x7a, 0x9f, 0x5c, 0x27, 0xee, 0x68, 0x7a,
	0x4d, 0x7d, 0xcc, 0x5c, 0x95, 0x9e, 0x4b, 0x04, 0x62, 0x42, 0x32, 0x90, 0x6c, 0x32, 0x10, 0x7c,
	0x0c, 0xbb, 0xa2, 0x74, 0xae, 0x99, 0x59, 0xc7, 0x77, 0x5b, 0xd9, 0xc6, 0x18, 0x8c, 0x89, 0x17,
	0x32, 0x51, 0xa1, 0x25, 0x45, 0x01, 0xfe, 0x08, 0x76, 0x4e, 0xdd, 0x90, 0x2a, 0x66, 0xc2, 0x4d,
	0x5d, 0xf4, 0xcf, 0x59, 0x53, 0x93, 0xb8, 0x69, 0xbc, 0x9d, 0xe6, 0x06, 0xe2, 0x6e, 0xaf, 0xc8,
	0xd7, 0x3d, 0xe7, 0xe3, 0x1f, 0x32, 0x00, 0xf1, 0x6d, 0x43, 0x05, 0xc8, 0x0c, 0x4e, 0x8c, 0xf7,
	0x50, 0x19, 0x8a, 0x93, 0xfe, 0x49, 0x7f, 0xf0, 0x5d, 0xdf, 0xd0, 0xd0, 0x1e, 0xd4, 0x47, 0xe3,
	0x81, 0xd9, 0xfe, 0xb6, 0x6b, 0xf5, 0x07, 0x63, 0xeb, 0xf9, 0x60, 0xd2, 0xef, 0x18, 0x19, 0xd4,
	0x84, 0x87, 0x11, 0xb9, 0x7d, 0x6a, 0x76, 0xdb, 0x9d, 0x3f, 0x5a, 0xdd, 0xef, 0x7b, 0xa3, 0xf1,
	0xc8, 0xc8, 0xa2, 0xc7, 0xd0, 0x88, 0xf6, 0x86, 0x5d, 0xf3, 0xac, 0x37, 0x1a, 0xf5, 0x06, 0xfd,
	0x4e, 0xb7, 0xdf, 0xeb, 0x76, 0x8c, 0x1c, 0xda, 0x87, 0xbd, 0xe3, 0x41, 0x7f, 0xdc, 0xfd, 0x7e,
	0x6c, 0x4d, 0x46, 0x5d, 0xd3, 0x32, 0xbb, 0x7f, 0x98, 0xf4, 0xcc, 0x6e, 0xc7, 0xc8, 0x23, 0x03,
	0x2a, 0xc3, 0xf6, 0xf8, 0x77, 0x56, 0xaf, 0xff, 0xa2, 0x7d, 0xda, 0xeb, 0x18, 0x05, 0xc6, 0x3c,
	0x9c, 0x7c, 0x73, 0xda, 0x3b, 0xb6, 0x4e, 0x7b, 0xfd, 0x13, 0xc5, 0x83, 0x22, 0xb3, 0xa2, 0x6e,
	0x49, 0x19, 0xab, 0xd3, 0x1e, 0x77, 0x8d, 0x12, 0x13, 0x54, 0xdd, 0x1e, 0x4d, 0x86, 0xc3, 0x81,
	0x39, 0xee, 0x76, 0x0c, 0x1d, 0x21, 0xa8, 0x71, 0xc3, 0xb1, 0x32, 0x40, 0x75, 0xa8, 0x8e, 0x07,
	0x27, 0xdd, 0xfe, 0xca, 0x74, 0xb9, 0x75, 0x0b, 0xb9, 0xf6, 0x92, 0x5e, 0xa0, 0xa7, 0x50, 0x56,
	0x06, 0x5b, 0xb4, 0xc3, 0x73, 0x2e, 0x39, 0xea, 0x36, 0x91, 0x32, 0x5f, 0xca, 0xe4, 0xc6, 0xef,
	0xa1, 0x2f, 0xa1, 0xac, 0xcc, 0x90, 0x52, 0x32, 0x39, 0x55, 0x36, 0xeb, 0xf1, 0xbf, 0x00, 0x2b,
	0xc1, 0xd6, 0x3f, 0x0a, 0x50, 0x1c, 0x51, 0x3f, 0xb0, 0x5f, 0x11, 0xf4, 0x19, 0xe8, 0xc2, 0x18,
	0x9b, 0xc9, 0x2a, 0xe2, 0x6d, 0x11, 0x73, 0x94, 0xb4, 0x9a, 0xf8, 0x47, 0x03, 0xbf, 0x87, 0x3e,
	0x81, 0x42, 0x87, 0xcc, 0x08, 0x25, 0x6f, 0xc5, 0xfd, 0x31, 0xe4, 0xd8, 0xdc, 0x25, 0x79, 0xe5,
	0x08, 0xb6, 0x81, 0xf7, 0x09, 0x14, 0x7b, 0x5e, 0xb8, 0x20, 0x53, 0xba, 0xa6, 0x7a, 0x2f, 0x39,
	0xb5, 0xc6, 0x12, 0x5f, 0x00, 0xc4, 0x57, 0xf7, 0x2d, 0x85, 0x9e, 0x68, 0xe8, 0x73, 0xa8, 0x8c,
	0xa8, 0x1d, 0x50, 0x3e, 0xf4, 0x8c, 0x6f, 0x50, 0x55, 0x75, 0xe7, 0x75, 0x73, 0x47, 0xfd, 0x7b,
	0x22, 0x36, 0xf6, 0x15, 0x00, 0x17, 0x10, 0x33, 0x42, 0x45, 0x32, 0xf1, 0x55, 0x73, 0xff, 0xee,
	0x88, 0xb5, 0x12, 0x3c, 0xd2, 0xd0, 0x2f, 0xa0, 0xfa, 0xdc, 0xf5, 0xdc, 0xf0, 0x22, 0xb2, 0x28,
	0xff, 0x30, 0x60, 0xb3, 0xd2, 0x06, 0x30, 0x3e, 0x67, 0x7d, 0xbd, 0xed, 0x3c, 0x77, 0x67, 0xeb,
	0x40, 0x3f, 0x5c, 0x9b, 0x62, 0xd4, 0xc8, 0x9e, 0x42, 0x95, 0x01, 0x12, 0xf5, 0xea, 0x61, 0x2a,
	0x26, 0xeb, 0x73, 0x09, 0x97, 0xfc, 0x35, 0x6b, 0x96, 0x6d, 0x67, 0x35, 0x4b, 0x18, 0x6b, 0xac,
	0xdb, 0xed, 0x7e, 0xc5, 0xda, 0x59, 0xde, 0xa8, 0x6e, 0x51, 0x90, 0x1e, 0xe8, 0xd7, 0x50, 0x16,
	0x2e, 0xf3, 0x6e, 0x78, 0xcd, 0xe1, 0xfd, 0xbb, 0x4d, 0xbe, 0x6a, 0xb6, 0x0d, 0x3b, 0x2b, 0xb3,
	0x4a, 0xa3, 0xbf, 0x9b, 0x22, 0xb5, 0xc9, 0x7c, 0x0b, 0x2a, 0x92, 0x94, 0x66, 0x3f, 0x55, 0xa6,
	0xf5, 0xb7, 0x02, 0xe4, 0xc5, 0x63, 0xf7, 0x1b, 0x30, 0x44, 0xf6, 0x28, 0x4d, 0x97, 0x78, 0x65,
	0xe3, 0x66, 0xbb, 0xf9, 0xfe, 0x7a, 0xc7, 0x16, 0x5b, 0x6f, 0x83, 0x21, 0x8a, 0xbc, 0x22, 0x2f,
	0x6c, 0x26, 0xda, 0xe6, 0x6d, 0x2a, 0x9e, 0x41, 0x5d, 0x66, 0x8d, 0xa2, 0xa3, 0xaa, 0x16, 0x8c,
	0xad, 0xe2, 0x5f, 0xf2, 0x39, 0xd5, 0xbf, 0x24, 0x9b, 0xa5, 0xd3, 0x81, 0x7b, 0xc6, 0xa6, 0x91,
	0x50, 0x31, 0x1a, 0xae, 0xe7, 0xd1, 0x66, 0xab, 0x4f, 0x34, 0xd4, 0x81, 0x5a, 0xdb, 0x71, 0xd4,
	0x8e, 0xeb, 0x61, 0x84, 0x5b, 0xf2, 0xc1, 0x6b, 0x36, 0xee, 0x34, 0x6e, 0xb1, 0x13, 0x1d, 0xa8,
	0xdf, 0x79, 0x24, 0xd1, 0xbe, 0x02, 0xe0, 0x9a, 0xae, 0xf4, 0x50, 0x7e, 0x0f, 0xc6, 0xfa, 0x0b,
	0x88, 0x84, 0xd5, 0x94, 0x87, 0x71, 0x9b, 0x3f, 0x3c, 0x8f, 0xaa, 0x89, 0x17, 0x17, 0x89, 0x9c,
	0x5b, 0x7f, 0x85, 0x37, 0x78, 0x72, 0x0c, 0x48, 0x26, 0x43, 0xfc, 0xc8, 0xde, 0xc1, 0xb5, 0x99,
	0xd2, 0x96, 0x25, 0xb3, 0x02, 0x9d, 0xb1, 0xb6, 0x26, 0xd9, 0x97, 0xed, 0xa5, 0x49, 0x6d, 0xf6,
	0x63, 0x77, 0xe2, 0xcd, 0xff, 0x37, 0x25, 0xad, 0x6f, 0xa0, 0x38, 0x0c, 0xc8, 0x95, 0x4b, 0xae,
	0xd9, 0x53, 0xc5, 0xaa, 0x4b, 0xb4, 0x7c, 0xeb, 0x82, 0xf6, 0xb2, 0xc0, 0xff, 0x5e, 0xff, 0xe5,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb1, 0xad, 0xb7, 0x85, 0x6b, 0x17, 0x00, 0x00,
}
